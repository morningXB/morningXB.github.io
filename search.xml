<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[排序算法-java]]></title>
      <url>%2F2017%2F03%2F16%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-java%2F</url>
      <content type="text"><![CDATA[排序算法快速排序 QuickSort快速排序是一个就地排序，分而治之，大规模递归的算法。从本质上来说，它是归并排序的就地版本。快速排序可以由下面四步组成。 （1） 如果不多于1个数据，直接返回。 （2） 一般选择序列最左边的值作为支点数据。 （3） 将序列分成2部分，一部分都大于支点数据，另外一部分都小于支点数据。 （4） 对两边利用递归排序数列。 快速排序比大部分排序算法都要快。尽管我们可以在某些特殊的情况下写出比快速排序快的算法，但是就通常情况而言，没有比它更快的了。快速排序是递归的，对于内存非常有限的机器来说，它不是一个好的选择。 归并排序 MergeSort归并排序先分解要排序的序列，从1分成2，2分成4，依次分解，当分解到只有1个一组的时候，就可以排序这些分组，然后依次合并回原来的序列中，这样就可以排序所有数据。合并排序比堆排序稍微快一点，但是需要比堆排序多一倍的内存空间，因为它需要一个额外的数组。 堆排序 HeapSort堆排序适合于数据量非常大的场合（百万数据）。 堆排序不需要大量的递归或者多维的暂存数组。这对于数据量非常巨大的序列是合适的。比如超过数百万条记录，因为快速排序，归并排序都使用递归来设计算法，在数据量非常大的时候，可能会发生堆栈溢出错误。 堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。 Shell排序 ShellSortShell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。平均效率是O(nlogn)。其中分组的合理性会对算法产生重要的影响。现在多用D.E.Knuth的分组方法。 Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。 插入排序 InsertSort插入排序通过把序列中的值插入一个已经排序好的序列中，直到该序列的结束。插入排序是对冒泡排序的改进。它比冒泡排序快2倍。一般不用在数据大于1000的场合下使用插入排序，或者重复排序超过200数据项的序列。 冒泡排序 BubbleSort冒泡排序是最慢的排序算法。在实际运用中它是效率最低的算法。它通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。它是O(n^2)的算法。 交换排序 ExchangeSort 和选择排序 SelectSort这两种排序方法都是交换方法的排序算法，效率都是 O(n2)。在实际应用中处于和冒泡排序基本相同的地位。它们只是排序算法发展的初级阶段，在实际中使用较少。 基数排序 RadixSort基数排序和通常的排序算法并不走同样的路线。它是一种比较新颖的算法，但是它只能用于整数的排序，如果我们要把同样的办法运用到浮点数上，我们必须了解浮点数的存储格式，并通过特殊的方式将浮点数映射到整数上，然后再映射回去，这是非常麻烦的事情，因此，它的使用同样也不多。而且，最重要的是，这样算法也需要较多的存储空间。 总结 Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296package com.whut.sort;/** * 排序算法 * @author Bin * */public class SortUtils &#123;private static int[] t;// 全局的样本// 此处之排列int类型。。。/** * 冒泡排序 * * @param data * @return */public static int[] bublleSort(int[] data) &#123; int len = data.length; for (int i = 1; i &lt; len; i++) &#123; for (int j = len - 1; j &gt;= i; j--) &#123; if (data[j] &lt; data[j - 1]) &#123; int temp = data[j - 1]; data[j - 1] = data[j]; data[j] = temp; &#125; &#125; &#125; return data;&#125;/** * 优化的冒泡排序 * * @param data * @return */public static int[] optbublleSort(int[] data) &#123; int len = data.length; for (int i = 1; i &lt; len; i++) &#123; boolean flag = false;// 设置一个标志，若不变说明已排序完成 for (int j = len - 1; j &gt;= i; j--) &#123; if (data[j] &lt; data[j - 1]) &#123; flag = true; int temp = data[j - 1]; data[j - 1] = data[j]; data[j] = temp; &#125; &#125; if (flag == false) &#123; return data; &#125; &#125; return data;&#125;/** * 直接插入排序 * * @param data * @return */public static int[] insertSort(int[] data) &#123; int left = 0, right = data.length; // 2 3 4 1 for (int i = left + 1; i &lt; right; i++) &#123; int temp = data[i]; for (int j = 0; j &lt; i; j++) &#123; if (temp &lt; data[j]) &#123; // 交换 int t = i - 1; do &#123; data[t + 1] = data[t]; t--; &#125; while (t &gt; j - 1); data[j] = temp; break; &#125; &#125; &#125; return data;&#125;/** * 搜索插入的位置对排序部分使用二分搜索法 * * @param data * @return */public static int[] binaryInsertSort(int[] data) &#123; int left = 0, right = data.length; for (int i = left + 1; i &lt; right; i++) &#123; int temp = data[i]; int low = 0, high = i - 1, mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (temp &lt; data[mid]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; for (int k = i; k &gt; low; k--) &#123; data[k] = data[k - 1]; &#125; data[low] = temp; &#125; return data;&#125;/** * 希尔排序 适合于大数据排序 用gap间隔gap缩小到一排序完成，后续排序在前面的基础上，开始gap较大，数据小排序快。 * * @param data * @return */public static int[] shellSort(int[] data) &#123; int left = 0, right = data.length; int gap = right - left; do &#123; gap = gap / 3 + 1; for (int i = gap + left; i &lt; right; i++) &#123; int temp = data[i]; if (temp &lt; data[i - gap]) &#123; int j = i - gap; do &#123; data[j + gap] = data[j]; j = j - gap; &#125; while (j &gt;= left &amp;&amp; temp &lt; data[j]); data[j + gap] = temp; &#125; &#125; &#125; while (gap &gt; 1); return data;&#125;/** * 快速排序 一个递归过程 分块处理 优化方法：对于小规模的数组直接用插入排序，或者先忽略小规模数组，拍完后整体用插入排序。 * 可在头尾中间端选取中间值作为基准元素防止左右划分严重不平衡。所以说快排以来与数据输入的顺序。 * * @param data * @return */public static int[] quickSort(int[] data) &#123; t = data; quickSort(0, data.length - 1); return t;&#125;private static void quickSort(int left, int right) &#123; if (left &lt; right) &#123; int pos = getPos(left, right); quickSort(left, pos - 1); quickSort(pos + 1, right); &#125;&#125;private static int getPos(int left, int right) &#123; int temp = t[left]; int pos = left; for (int i = left + 1; i &lt;= right; i++) &#123; if (temp &gt; t[i]) &#123; pos++; if (pos != i) &#123; int tt = t[pos]; t[pos] = t[i]; t[i] = tt; &#125; &#125; &#125; t[left] = t[pos]; t[pos] = temp; return pos;&#125;/** * 选择排序 * * @param data * @return */public static int[] selectSort(int[] data) &#123; int len = data.length; for (int i = 1; i &lt; len; i++) &#123; int temp = data[i - 1]; for (int j = i; j &lt; len; j++) &#123; if (data[j] &lt; temp) &#123; temp = data[j]; data[j] = data[i - 1]; data[i - 1] = temp; &#125; &#125; &#125; return data;&#125;/** * 堆排序 * * @param data * @return */public static int[] heapSort(int[] data) &#123; t = data; int len = data.length; int currentPos = (len - 2) / 2; while (currentPos &gt;= 0) &#123; shiftDown(currentPos, len - 1); currentPos--; &#125; for (int i = len - 1; i &gt;= 0; i--) &#123; int temp = t[i]; t[i] = t[0]; t[0] = temp; shiftDown(0, i - 1); &#125; return t;&#125;/** * 对堆的currentPos位进行下滑调整 构造最大堆 * * @param currentPos */private static void shiftDown(int currentPos, int end) &#123; int i = currentPos; int j = 2 * i + 1; int temp = t[i];// 可能需要下滑的点 while (j &lt;= end) &#123; if (j + 1 &lt;= end &amp;&amp; t[j + 1] &gt; t[j]) &#123; j++; &#125; if (temp &gt;= t[j]) &#123; break; &#125; else &#123; t[i] = t[j]; i = j; j = 2 * j + 1; &#125; &#125; t[i] = temp;&#125;/** * 归并排序 * * @param data * @return */public static int[] mergeSort(int[] data) &#123; int left = 0; int right = data.length - 1; t = data; mergeSort(left, right); return t;&#125;private static void mergeSort(int left, int right) &#123; if (left &gt;= right) return; int mid = (left + right) / 2; mergeSort(left, mid); mergeSort(mid + 1, right); merge(left, mid, right);&#125;private static void merge(int left, int mid, int right) &#123; int[] temp = new int[t.length]; for (int m = 0; m &lt; t.length; m++) &#123; temp[m] = t[m]; &#125; int i = left; int j = mid + 1; int k = left; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (temp[i] &lt; temp[j]) &#123; t[k++] = temp[i++]; &#125; else &#123; t[k++] = temp[j++]; &#125; &#125; while (i &lt;= mid) &#123; t[k++] = temp[i++]; &#125; while (j &lt;= right) &#123; t[k++] = temp[j++]; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F14%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
